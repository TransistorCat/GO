# 区块链

## 密码学原理

### 哈希碰撞

两个不同的输入算出来的哈希值是相等的

输入空间>输入空间->不可避免

鸽笼原理也叫抽屉原理，把多于n个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件

#### 性质

##### 抗碰撞性（collision resistance）

碰撞自由(collision free)导致（无法证明）MD5寄

人为无法找到两个哈希值相等的数，只能穷举

###### 应用：难以篡改

H（m)只能找到一个唯一的哈希，如果m被改变那么没有另外一个和H（m）相等的m`,

如果有人想篡改m值而H(m)不变，则无法做到。

##### 不可逆性（hiding）

X->H(x)但是H(X)不能->X

(从H(x)无法推导出x) hiding性质前提是输入空间足够大，分布比较均匀。如果不是足够大，一般在x后面拼接一个随机数，如H(x||nonce)。

###### 应用：数字承诺（digital commitment）

和collision resistance 结合在一起，用来实现digital commitment(又称为digital equivalent of a sealed envelope)
把预测结果作为输入x，算出一个哈希值，讲哈希值公布，hiding让人们知道哈希值而不知道预测值，最后再将x公布，因为有collision resistance的性质，预测结果是不可篡改的。

##### 不可预测（puzzle friendly）

指哈希值的预算事先是不可预测的。假如哈希值是00...0XX...X，一样事先无法知道哪个值更容易算出这个结果，还是要一个一个带入。

###### 应用：工作量证明(proof of work)

比特币挖矿的过程中实际就是**找一个nonce**，nonce跟区块的块头里的其他信息合一起作为输入，得出的哈希值要小于等于某个指定的目标预值。H(block header)≤target。block header 指块头，块头里有很多域，其中一个域是我们可以设置的随机数nonce，挖矿的过程是不停的试随机数，使得block header取哈希后落在指定的范围之内。

puzzle friendly是指挖矿过程中没有捷径，为了使输出值落在指定范围，只能一个一个去试。所以这个过程还可以作为工作量证明(proof of work)。
挖矿很难，验证很容易一次就ok。(difficult to solve ,but easy to verify)



哈希函数叫作SHA-256(secure hash algorithm )以上三个性质它都是满足的。




### 签名

1. 在本地创立一个公私钥匙对(public key ,private key)，这就是一个账户。公私钥匙对是来自于非对称的加密技术(asymmetric encryption algorithm)。
2. 两人之间信息的交流可以利用密钥(encryption key)，A将信息加密后发给B，B收到后用密钥解密，因为加密和解密用的是同一个密钥，所以叫对称加密。前提是有渠道可以安全地把密钥分发给通讯的双方。因此对称加密的缺点就是密钥的分发不方便，因为在网络上很容易被窃听。
3. 非对称密钥是用一对密钥而不是一个，加密用公钥，解密用私钥，加密和解密用的都是接收方的公钥和私钥。公钥是不用保密的，私钥要保密但是私钥只要保存在本地就行，不用传给对方。**公钥相当于银行账号，别人转账只要知道公钥就行，私钥相当于账户密码，知道私钥可以把账户上钱转走。公钥和私钥是用来签名。****假如A想向B转10个比特币，A把交易放在区块链上，别人怎么知道这笔交易是A发起的呢?**这就需要A要用自己的私钥给交易签名，其他人收到这笔交易后，要用A的公钥去验证签名。签名用私钥，验证用公钥，用的仍然是同一个人的**。创建账户产生相同公私钥的可能性微乎其微，所以大量创建账户来窃取其他人账户是不可行的。我们假设产生公私钥时有一个好的随机源(a good source of randomness)，产生公私钥是随机的，如果随机源不好，就有可能产生相同的公私钥。比特币中用的签名算法，不仅是生成公私钥的时候要有好的随机源，之后每一次签名时也要有好的随机源。只要有一次签名用的随机源不好的话，就有可能泄露私钥。

## 数据结构

### 哈希指针

普通指针只存结构体位置，而哈希指针还存哈希值

只要一个数据结构是无环的(非循环链表)，都能用哈希指针代替普通指针。有环的话存在一个问题，他们的哈希值没法计算，没法确定一个哈希值固定的区块。



### 区块链表

![image-20220401170014423](C:\Users\你的姓名\Nutstore\1\我的坚果云\笔记\GO\image-20220401170014423.png)

1. 用哈希指针代替普通指针
2. 只要记住最后一个，就可以知道链中元素是否被篡改
3. 可以通过算前一个的哈希值，与后一个的比看是否一致来判断前一个是否准确

### 默克尔树(*Merkle tree*）

#### 节点

节点分为全节点和轻节点

全节点 每个block header都保存

轻节点 只保留根哈希值（类似比特币钱包）

![image-20220401171926058](C:\Users\你的姓名\Nutstore\1\我的坚果云\笔记\GO\image-20220401171926058.png)

1. 哈希节点是两个哈希值再取一个哈希和另一个这样的拼在一起，最后的叫根节点

2. 只要记住根哈希值就可以知道被改了

3. 每个date block分为block header(只存根哈希值）包有交易链表和block body

4. 提供Merkle proof 找到交易的节点从而找到到根的路径

   ![image-20220401232733751](C:\Users\你的姓名\AppData\Roaming\Typora\typora-user-images\image-20220401232733751.png)向一个某个全节点请求红色的哈希值，就可以一步一步推出根哈希值，与现有的进行比较，如何发生变化则黄色date block 发生交易
   
   对于一个轻节点来说，验证一个merkle proof复杂度是多少?假设最底层有n个交易，则merkle proof复杂程度是θ(log(n))。
   
   如果对叶节点的排列顺序做一些要求，比如按照交易的哈希值排序。每一个叶节点都是一次交易，对交易的内容取一次哈希，按照哈希值从小到大排列。要查的交易先算出一个哈希值，看看如果它在里面该是哪个位置。比如说在第三个第四个之间，这时提供的proof是第三个第四个叶节点都要往上到根节点。如果其中哈希值都是正确的，最后根节点算出的哈希值也是没有被改过的，说明第三、四个节点在原来的merkle tree里面，确实是相邻的点。要找的交易如果存在的话，应该在这两个节点中间。但是它没有出现，所以就不存在。其复杂度也是log形式，代价是要排序。排好序的叫作sorted merkle tree。比特币中没有用到这种排好序的merkle tree，因为比特币中不需要做不存在证明。





## 协议

double spending attack 花两次攻击

账本的内容要取得分布式的共识

FLP 在一个异步的系统里（网络传输时延没有上限）即使只有一位成员出现问题，那么也不能达成共识
